# Билет 1

## Точки сочленения и блоки в связном графе. Лемма о пересечении блоков. Каждое ребро содержится в единственном блоке.

### **Определение**

1. Вершина a ∈ V(G) называется точкой сочленения,
   если граф G − a несвязен.
2. Блоком называется любой максимальный по
   включению подграф графа G, не имеющий точек
   сочленения.
3. Блоки и точки сочленения несвязного графа — это блоки
   и точки сочленения его компонент.

+ В силу максимальности, блок графа G является
  индуцированным подграфом графа G на своем
  множестве вершин.
+ Любой подграф без точек сочленения H графа G
  входит хотя бы в один блок (так как H можно дополнить
  до максимального подграфа без точек сочленения).

### **Лемма 1**

Пусть B1 и B2 — два разных блока графа G, причём V(B1) ∩ V(B2) != ∅. Тогда V(B1) ∩ V(B2) состоит из точки сочленения a графа G, причем a — единственная точка сочленения, отделяющая B1 от B2.

#### **Доказательство**

+ Пусть |V(B1) ∩ V(B2)| ≥ 2. Тогда для любой вершины x ∈ V(B1 ∪ B2) граф B1 ∪ B2 − x связен. Следовательно, B1 ∪ B2 содержится в блоке
  B графа G, а B1 является собственным подграфом B, что противоречит максимальности B1.
+ Далее пусть V(B1) ∩ V(B2) = {a}. Так как a — общая
  вершина блоков B1 и B2, отделить B1 от B2 в графе G
  может только a.
+ Если a не отделяет B1 от B2 в графе G, то в G − a есть
  V(B1)V(B2)-путь P
+ Пусть H = B1 ∪ B2 ∪ P. Граф H − x связен для любой
  вершины x ∈ V(H). Поэтому H содержится в одном
  блоке B графа G, а блок B1 — собственный подграф B,
  противоречие.
+ Итак, a — единственная вершина, которая отделяет B1
  от B2 в графе G. Следовательно, граф G − a несвязен, то
  есть a — точка сочленения G.
+ По Лемме 1 любой подграф без точек сочленения H
  графа G с v(H) > 1 входит ровно в один блок. В
  частности, любое ребро графа входит ровно в один блок.
+ Если у связного графа G хотя бы две вершины, то
  каждая его вершина смежна хотя бы с одной другой
  вершиной. Следовательно, любой блок графа G содержит
  хотя бы две вершины.

### **Определение**

+ Построим граф B(G), вершины которого соответствуют
  всем точкам сочленения a1,..., an графа G и всем его
  блокам B1,..., Bm (мы будем обозначать эти вершины
  так же, как и блоки). Вершины ai и Bj будут смежны,
  если ai ∈ V(Bj). Других рёбер в этом графе нет.
  **Граф B(G) называется деревом блоков и точек
  сочленения графа G.**

---

# Билет 2

## Дерево блоков и точек сочленения. Лемма о пути и теорема.

### **Лемма 2**

Пусть B1 и B2 — два разных блока графа G, а P — путь
между ними в графе B(G). Тогда точки сочленения
графа G, отделяющие B1 от B2 — это в точности те
точки сочленения, что лежат на пути P. Остальные
точки сочленения не разделяют даже объединение
блоков пути P

#### **Доказательство**

* Пусть x — точка сочленения графа G,
  не лежащая на пути P, а H — объединение всех блоков
  пути P.
* • Для любого блока B пути P граф B − x связен. Если B
  — не B1 и не B2, то в нем можно пройти между двумя
  точками сочленения, входящими в P (эти точки отличны
  от x). Поэтому H − x — связный граф.
* Пусть a — точка сочленения, лежащая на P, и она
  входит в блоки B′1 и B′2 пути P.
* Обозначим через H1 объединение всех блоков,
  лежащих на пути P от B1 до a, а через H2 —
  объединение всех блоков, лежащих на пути P от a до B2.
* По доказанному выше, a не разделяет ни один из
  графов H1 и H2.
* С другой стороны, [по Лемме 1](#лемма-1) точка сочленения a
  отделяет блок B′1 от блока B′2, а значит, a отделяет H1 от
  H2 и, в частности, B1 от B2.

### **Теорема 1**

1) Дерево блоков и точек сочленения связного графа G
   — это действительно дерево, все листья которого
   соответствуют блокам.
2) Точка сочленения a разделяет два блока B1 и B2 в
   графе G, если и только если a разделяет B1 и B2 в B(G).

#### **Доказательство**

1. *B(G) — связный граф.*

+ Для любых двух вершин B(G) (не важно, блоков или
  точек сочленения) рассмотрим путь Q в G между ними.
+ Путь Q перестраивается в путь в B(G) так:
  — участок пути Q, проходящий по одному блоку графа
  G, заменяем на соответствующую блоку вершину в B(G);
  — переход Q между различными блоками [по Лемме 1](#лемма-1)
  осуществляется через их общую точку сочленения —
  вершину B(G).
+ Предположим, что в B(G) есть простой цикл Z и
  рассмотрим подграф H — объединение всех блоков этого
  цикла.
+ Между любыми двумя входящими в Z блоками есть
  два независимых пути в B(G).
+ [По Лемме 2](#лемма-2) граф H не имеет точек сочленения (они
  должны бы были лежать на двух путях без общих
  внутренних точек).
+ Следовательно, существует блок B, содержащий H, а
  все (хотя бы два) блока цикла Z — собственные
  подграфы B, что невозможно.
+ *Таким образом, B(G) — дерево.*
+ Если лист B(G) соответствует точке сочленения a, то
  [по Лемме 2](#лемма-2) граф G − a связен, противоречие.

2. В дереве B(G) есть единственный путь между B1 и B2.
   [По Лемме 2](#лемма-2) в точности точки сочленения с этого пути
   отделяют B1 от B2 в графе G.

---

# Билет 3

## Крайние блоки.

### **Определение**

1. Назовем блок B крайним, если он соответствует
   висячей вершине дерева блоков и точек сочленения.
2. Внутренность Int(B) блока B — это множество всех его
   вершин, не являющихся точками сочленения в графе G.

+ Нетрудно понять, что блок недвусвязного графа G
  является крайним тогда и только тогда, когда он
  содержит ровно одну точку сочленения.
+ Внутренность некрайнего блока может быть пустой.
  Внутренность крайнего блока всегда непуста.
+ Если у связного графа G есть точки сочленения, то он
  имеет хотя бы два крайних блока.
+ Если B — блок графа G, а x ∈ Int(B), то граф G − x
  связен.

### **Лемма 3**

Пусть B — крайний блок связного графа G, а G′ = G − Int(B). Тогда граф G′ связен, а блоки G′ — это все блоки G, кроме B.

#### **Доказательство**

+ Пусть a ∈ V(B) — точка сочленения, отрезающая
  крайний блок B от остального графа. Тогда Int(B) — это
  одна из компонент связности графа G − a, откуда
  очевидно следует связность графа G′.
+ Все отличные от B блоки графа G являются
  подграфами G′, не имеют точек сочленения и являются
  максимальными подграфами G′ с таким свойством (они
  были максимальными даже в G). Следовательно, все они
  — блоки графа G′.
+ Пусть B′ — блок графа G′. Очевидно, v(G′) ≥ 2,
  поэтому B′содержит хотя бы одно ребро e, которое в
  графе G лежит в некотором блоке B∗ != B. Теперь
  очевидно, что B∗ = B ′.

---

# Билет 4

## Алгоритм построения блоков с помощью последовательных разрезов графа по точкам сочленения.

### **Определение**

+ Вершина a ∈ V(G) называется точкой сочленения, если граф G − a несвязен.

**]** Пусть U1,. . . , Uk — все компоненты связности графа G − a, a Gi = G(Ui ∪ {a}). Разрежем граф G на графы G1,. . . , Gk .

### **Лемма 4.1**

Пусть b ∈ UiТогда b разделяет вершины x, y ∈ Ui в Gi, если и только если b разделяет их в G.

#### **Доказательство**

+ **Необходимость**
  Если в G − b нет xy-пути, то его, очевидно, нет и в Gi − b.
+ **Достаточность**
  Наоборот, пусть x и y лежат в разных компонентах
  связности графа Gi − b. Не умаляя общности можно
  считать, что компонента связности W ∋ x не содержит a.
  Тогда W — компонента связности графа G − b, то есть,
  и в этом графе нет xy-пути.

### **Лемма 4.2**

Все точки сочленения графов G1, . . . , Gk — это в точности все точки сочленения графа G, кроме a.

#### **Доказательство**

+ Так как Gi − a — компонента графа G − a, вершина a не является точкой сочленения ни в одном из графов G1,. . . , Gk .
+ Любая другая точка сочленения графа G лежит ровно в одном из графов G1,. . . , Gk и является в нем точкой сочленения по пункту 1.
+ Также [из пункта 1](#лемма-4.1) следует, что других точек сочленения в графах G1,. . . , Gk нет.

### **Алгоритм разбиения связного графа на блоки**

+ Выберем точку сочленения a и разрежем по ней G —
  заменим граф G на полученные при этом графы G1, . . . , Gk
+ Каждым следующим шагом мы будем брать один из
  имеющихся графов, выбирать в нем точку сочленения и
  разрезать его по ней.
+ И так далее, пока хотя бы один из полученных графов
  имеет точку сочленения.

### **Теорема 2**

В результате описанного выше алгоритма разрезания графа
по точкам сочленения вне зависимости от порядка действий
получатся блоки графа G.

#### **Доказательство**

+ [По Лемме 4](#лемма-4.1) мы вне зависимости от порядка действий
  проведем разрезы по всем точкам сочленения графа G и
  только по ним.
+ Пусть B — блок графа G. Тогда в графе G множество V(B)
  не было разделено ни одной из точек сочленения. Значит, [по
  пункту 1 Леммы 4](#Лемма-4.1) множество V(B) не было разрезано при
  нашем алгоритме.
+ Так как в результате алгоритма получились индуцированные
  подграфы графа G, один из них — скажем, H — является
  надграфом B.
+ Если H != B, то рассмотрим вершину c ∈ V(H) \ V(B). В
  графе G существует точка сочленения a, отделяющая c от
  V(B). Тогда в силу [леммы 4](#лемма-4.1) при разрезе по a вершина c была
  отделена от блока B, противоречие.

---

# Билет 5

## Рекурсивный алгоритм построения дерева блоков и точек сочленения.

+ Выберем точку сочленения a и разрежем по ней G —
  заменим граф G на полученные при этом графы
  G1,..., Gk .
+ В каждом из графов G1, . . . , Gk построим деревья
  блоков и точек сочленения. Пусть, скажем, B(Gi) = Ti
+ В графе Gi [по Лемме 4](#лемма-4.1) вершина a не является точкой
  сочленения.
+ Значит, [по Лемме 1](#лемма-1) в Gi есть единственный блок Bi,
  содержащий a.
+ Построим дерево B(G), присоединив к точке a деревья
  T1,..., Tk (дерево Ti присоединяем ребром aBi).

### **Теорема 3**

В результате описанного выше алгоритма будет построено
дерево блоков и точек сочленения графа G.

#### **Доказательство**

+ В качестве **базы построения** отметим, что
  граф без точек сочленения является своим единственным
  блоком и его дерево блоков и точек сочленения тривиально.
  **Шаг построения.**
+ Точка сочленения a должна быть соединена в точности с
  теми блоками графа G, которые ее содержат.
+ Из алгоритма разбиения графа на блоки следует, что это в
  точности блоки B1,..., Bk .
+ Любая другая точка сочленения b попала в одну из частей
  при разрезе графа G по a — скажем, в G1.
+ Тогда все блоки графа G, содержащие b, лежат в G1 и
  являются блоками графа G1 (это следует из алгоритма
  разбиения на блоки уже графа G1).
+ Следовательно, b соединена в T1 (а значит, и в построенном
  нами объединенном дереве блоков) в точности с теми
  блоками, с которыми b должна быть соединена в B(G). □
+ Из алгоритма построения дерева блоков и точек
  сочленения можно вывести его свойства (в частности, то,
  что это дерево и все его листья соответствуют блокам).
+ Более того, из алгоритма понятно, что каждая точка
  сочленения a разделяет блоки в B(G), если и только
  если она их разделяет в G, а dB(G)(a) равняется числу
  компонент связности графа G − a

---

# Билет 6

## Разбиение двусвязного графа на два связных графа заданных размеров.

### **Определение**

---

# Билет 7

## Теорема Менгера в форме Гёринга (для двух множеств).

---

# Билет 8

## Следствие — две формы теоремы Менгера (для двух вершин и для вершины и множества).

---

# Билет 9

## Теорема Уитни.

---

# Билет 10

## Теорема Дирака о цикле, содержащем заданные k вершин

---

# Билет 11

## Лемма о k-вершинном разделяющем множестве в k-связном графе

---

# Билет 12

## Стягивание ребра в двусвязном графе без потери двусвязности.

---

# Билет 13

## Зависимые и независимые разделяющие множества.

---

# Билет 14

## Разбиение k-связного графа парой независимых разделяющих множеств: лемма о компонентах.

---

# Билет 15

## Стягивание ребра в трёхсвязном графе без потери трёхсвязности.

---
