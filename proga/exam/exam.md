# 1. Обобщенные и параметризованные типы. Создание параметризованных классов.

Обобщенные типы (Generics) — это механизм в Java, который позволяет создавать классы, интерфейсы и методы, работающие с различными типами данных, при этом сохраняя строгую проверку типов на этапе компиляции. Основная цель — повысить безопасность типов и избежать необходимости явного приведения типов (casting).

Параметризованный класс — это класс, который может быть параметризован одним или несколькими типами. Эти типы указываются в угловых скобках `<>`.

**Создание параметризованного класса:** Для создания такого класса мы используем параметр типа (например, `T`, `E`, `K`, `V`) в его объявлении. Этот параметр затем можно использовать внутри класса как обычный тип для полей, методов и локальных переменных.

**Пример:** Создадим простой класс `Box`, который может хранить объект любого типа.

```java
// Объявление параметризованного класса Box с параметром типа T
public class Box<T> {
    // Поле типа T
    private T value;

    // Конструктор
    public Box(T value) {
        this.value = value;
    }

    // Геттер, возвращающий значение типа T
    public T getValue() {
        return value;
    }

    // Сеттер, принимающий значение типа T
    public void setValue(T value) {
        this.value = value;
    }

    public void showType() {
        if (value != null) {
            System.out.println("Тип T: " + value.getClass().getName());
        } else {
            System.out.println("Значение не установлено.");
        }
    }
}

// Использование класса Box
public class Main {
    public static void main(String[] args) {
        // Создаем Box для Integer
        Box<Integer> integerBox = new Box<>(123);
        System.out.println("Значение в integerBox: " + integerBox.getValue());
        integerBox.showType(); // Тип T: java.lang.Integer

        // Создаем Box для String
        Box<String> stringBox = new Box<>("Привет, мир!");
        System.out.println("Значение в stringBox: " + stringBox.getValue());
        stringBox.showType(); // Тип T: java.lang.String

        // Ошибка компиляции! Попытка положить String в Box<Integer>
        // integerBox.setValue("не число");
    }
}
```

**Преимущества Generics:**
1. **Безопасность типов:** Компилятор проверяет, что в коллекцию или класс помещаются объекты только совместимого типа.
2. **Устранение приведения типов:** Не нужно вручную приводить типы при извлечении объектов, что делает код чище и безопаснее.
3. **Переиспользование кода:** Один и тот же класс можно использовать для работы с разными типами данных.

---

# 2. Работа с параметризованными методами. Ограничение типа сверху или снизу.

**Параметризованный метод (Generic Method)** — это метод, который имеет собственный параметр типа. Этот параметр указывается в угловых скобках перед возвращаемым типом метода. Он полезен, когда обобщенная логика нужна только для одного метода, а не для всего класса.

```java
public class Util {
    // <T> объявляет, что это параметризованный метод
    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.print(element + " ");
        }
        System.out.println();
    }
}
```

**Ограничение типа (Bounded Wildcards)** используется для того, чтобы ограничить типы, которые можно использовать в качестве аргументов для обобщенных типов. Это делается с помощью ключевых слов `extends` и `super`.

### 1. Ограничение сверху (Upper Bounded Wildcard) — `<? extends Type>`
- Означает *“любой тип, который является Type или его подтипом”*.
- Используется, когда вы хотите читать данные из структуры (Producer). Вы не можете добавлять элементы в такую коллекцию (кроме `null`), потому что компилятор не знает точного типа.
- **Принцип PECS:** *Producer Extends*.

**Пример:** Метод, который вычисляет сумму чисел в списке, где элементы могут быть `Integer`, `Double`, `Float` и т.д. Все они наследуются от `Number`.

```java
public static double sumOfList(List<? extends Number> list) {
    double sum = 0.0;
    for (Number n : list) {
        sum += n.doubleValue(); // Мы можем безопасно читать, т.к. любой элемент - это Number
    }
    // list.add(123); // Ошибка компиляции! Нельзя добавлять.
    return sum;
}
```

### 2. Ограничение снизу (Lower Bounded Wildcard) — `<? super Type>`
- Означает *“любой тип, который является Type или его супертипом”*.
- Используется, когда вы хотите записывать данные в структуру (Consumer). Вы можете безопасно добавлять объекты типа `Type` или его подтипов. При чтении вы получите только `Object`.
- **Принцип PECS:** *Consumer Super*.

**Пример:** Метод, который добавляет несколько целых чисел в список. Список может быть `List<Integer>`, `List<Number>` или `List<Object>`.

```java
public static void addIntegers(List<? super Integer> list) {
    list.add(1);
    list.add(2);
    // Object o = list.get(0); // Читать можно, но получим только Object
}

public static void main(String[] args) {
     List<Number> numberList = new ArrayList<>();
     addIntegers(numberList);
     System.out.println(numberList); // [1, 2]
}
```

---

# 3. Класс Number. Классы-обертки (Wrappers). Автоупаковка и автораспаковка.

### Класс Number
- `java.lang.Number` — это абстрактный класс, который является суперклассом для всех стандартных числовых классов-оберток в Java: `Byte`, `Short`, `Integer`, `Long`, `Float`, `Double`.
- Он предоставляет методы для преобразования значения, хранящегося в объекте-обертке, в любой из примитивных числовых типов:
  - `intValue()`, `longValue()`, `floatValue()`, `doubleValue()`, `byteValue()`, `shortValue()`.

### Классы-обертки (Wrappers)
- Это классы, которые “оборачивают” примитивные типы данных в объекты. Это необходимо, потому что коллекции и многие другие механизмы Java (например, Generics) работают только с объектами.
- Каждому примитивному типу соответствует свой класс-обертка:
  - `byte` → `Byte`
  - `short` → `Short`
  - `int` → `Integer`
  - `long` → `Long`
  - `float` → `Float`
  - `double` → `Double`
  - `char` → `Character`
  - `boolean` → `Boolean`

### Автоупаковка (Autoboxing)
- Это автоматическое преобразование примитивного типа в соответствующий ему класс-обертку. Компилятор Java делает это неявно.

```java
// Раньше (до Java 5):
Integer iObject = Integer.valueOf(100);

// Сейчас (с автоупаковкой):
Integer iObject = 100; // int 100 автоматически преобразуется в Integer
```

### Автораспаковка (Unboxing)
- Это обратный процесс: автоматическое преобразование объекта класса-обертки в соответствующий примитивный тип.

```java
// Раньше:
int iPrimitive = iObject.intValue();

// Сейчас (с автораспаковкой):
int iPrimitive = iObject; // Integer iObject автоматически преобразуется в int
```

**Важный момент:** Автораспаковка может привести к `NullPointerException`, если объект-обертка равен `null`.

```java
Integer n = null;
int num = n; // Бросит NullPointerException во время выполнения
```

---

# 4. Коллекции. Виды коллекций. Интерфейсы List, Queue, Deque, Set, Map.

**Java Collections Framework** — это набор классов и интерфейсов для хранения и обработки групп объектов. Он предоставляет готовые структуры данных и алгоритмы.

### Основные интерфейсы коллекций:

1. **`Collection<E>`** — корневой интерфейс иерархии (кроме `Map`). Определяет базовые операции: добавление, удаление, проверка размера, проверка на наличие элемента.
2. **`List<E>`** — упорядоченная коллекция (последовательность), в которой элементы могут дублироваться. Элементы имеют индекс, доступ к ним осуществляется по этому индексу.
   - **Основные реализации:** `ArrayList`, `LinkedList`.
3. **`Set<E>`** — коллекция, которая не хранит дублирующихся элементов. Порядок элементов, как правило, не гарантируется (зависит от реализации).
   - **Основные реализации:** `HashSet` (неупорядоченный), `LinkedHashSet` (в порядке добавления), `TreeSet` (отсортированный).
4. **`Queue<E>`** — коллекция, предназначенная для хранения элементов перед их обработкой. Обычно работает по принципу FIFO (First-In-First-Out, “первым пришел — первым ушел”).
   - **Методы для добавления:** `add()`, `offer()`.
   - **Методы для извлечения:** `remove()`, `poll()`.
   - **Методы для просмотра:** `element()`, `peek()`.
   - **Основные реализации:** `LinkedList`, `PriorityQueue`.
5. **`Deque<E>`** (Double-Ended Queue) — двунаправленная очередь. Позволяет добавлять и удалять элементы с обоих концов. Может использоваться как очередь (FIFO) или как стек (LIFO - Last-In-First-Out).
   - **Основные реализации:** `ArrayDeque`, `LinkedList`.

### Интерфейс `Map<K, V>`
- Стоит особняком от иерархии `Collection`.
- Хранит данные в виде пар “ключ-значение” (K-V).
- Каждый ключ в `Map` должен быть уникальным. Одному ключу соответствует одно значение.
- Не является “коллекцией” в строгом смысле, но входит в Collections Framework.
- **Основные реализации:** `HashMap` (неупорядоченный), `LinkedHashMap` (в порядке добавления), `TreeMap` (ключи отсортированы).

---

# 5. Обход элементов коллекции. Интерфейсы Iterable, Iterator и ListIterator

**Обход элементов коллекции** — это процесс последовательного доступа к каждому элементу коллекции для выполнения каких-либо действий.

### 1. Интерфейс `Iterable<T>`
- Реализуется всеми классами коллекций из `java.util.Collection`.
- Означает, что по объектам этого класса можно “проитерироваться”.
- Содержит один метод `iterator()`, который возвращает объект типа `Iterator`.
- Именно благодаря этому интерфейсу мы можем использовать цикл `for-each`.

```java
List<String> names = List.of("Alice", "Bob", "Charlie");
// Цикл for-each работает, потому что List реализует Iterable
for (String name : names) {
    System.out.println(name);
}
```

### 2. Интерфейс `Iterator<E>`
- Основной механизм для обхода элементов любой коллекции.
- Позволяет безопасно удалять элементы из коллекции во время итерации.
- **Основные методы:**
  - `boolean hasNext()`: возвращает `true`, если в коллекции есть еще элементы.
  - `E next()`: возвращает следующий элемент в коллекции и сдвигает “курсор”.
  - `void remove()`: удаляет последний элемент, возвращенный методом `next()`. Может быть вызван только один раз после `next()`.

**Пример:**
```java
List<Integer> numbers = new ArrayList<>(List.of(1, 2, 3, 4, 5, 6));
Iterator<Integer> iterator = numbers.iterator();

while (iterator.hasNext()) {
    Integer number = iterator.next();
    if (number % 2 == 0) {
        iterator.remove(); // Безопасное удаление четных чисел
    }
}
System.out.println(numbers); // [1, 3, 5]
```

*Пытаться удалить элемент напрямую из коллекции во время итерации (кроме как через `iterator.remove()`) приведет к `ConcurrentModificationException`.*

### 3. Интерфейс `ListIterator<E>`
- Расширяет `Iterator` и предназначен специально для `List`.
- Позволяет двигаться по списку в обоих направлениях.
- Позволяет изменять и добавлять элементы в список во время итерации.
- **Дополнительные методы:**
  - `boolean hasPrevious()`: проверяет, есть ли предыдущий элемент.
  - `E previous()`: возвращает предыдущий элемент.
  - `int nextIndex()` / `int previousIndex()`: возвращают индексы.
  - `void set(E e)`: заменяет последний элемент, возвращенный `next()` или `previous()`.
  - `void add(E e)`: вставляет новый элемент перед “курсором”.

---

# 6. Сортировка элементов коллекций. Интерфейсы Comparable и Comparator.

Для сортировки объектов в Java используются два основных интерфейса: `Comparable` и `Comparator`.

### 1. Интерфейс `Comparable<T>`
- Определяет “естественный порядок” сортировки для объектов класса.
- Находится в пакете `java.lang`.
- Класс, который вы хотите сортировать, должен реализовать этот интерфейс.
- Содержит один метод: `int compareTo(T o)`.
  - Возвращает отрицательное число, если текущий объект (`this`) меньше `o`.
  - Возвращает ноль, если объекты равны.
  - Возвращает положительное число, если текущий объект больше `o`.

**Пример:**
```java
public class Person implements Comparable<Person> {
    private String name;
    private int age;

    // конструкторы, геттеры...

    @Override
    public int compareTo(Person other) {
        // Сортировка по возрасту
        return Integer.compare(this.age, other.age);
    }
}

List<Person> people = new ArrayList<>();
// … добавляем людей
Collections.sort(people); // Сортирует по “естественному порядку” (по возрасту)
```

### 2. Интерфейс `Comparator<T>`
- Определяет внешний, настраиваемый порядок сортировки.
- Находится в пакете `java.util`.
- Используется, когда:
  - Класс не реализует `Comparable`.
  - Нужно определить несколько разных способов сортировки.
  - Вы не можете изменить исходный код класса.
- Содержит основной метод: `int compare(T o1, T o2)`.
  - Работает аналогично `compareTo`: возвращает `<0`, `0`, `>0`.

**Пример:**
```java
// Компаратор для сортировки Person по имени
public class PersonNameComparator implements Comparator<Person> {
    @Override
    public int compare(Person p1, Person p2) {
        return p1.getName().compareTo(p2.getName());
    }
}

List<Person> people = new ArrayList<>();
// … добавляем людей
// Используем компаратор для сортировки
people.sort(new PersonNameComparator());

// С Java 8 можно использовать лямбда-выражения:
people.sort(Comparator.comparing(Person::getName));
```

### Методы сортировки:
- `Collections.sort(List<T> list)`: сортирует список, используя естественный порядок (`Comparable`).
- `Collections.sort(List<T> list, Comparator<? super T> c)`: сортирует с использованием заданного `Comparator`.
- `list.sort(Comparator<? super T> c)`: метод самого списка, появился в Java 8.